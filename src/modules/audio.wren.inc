// auto-generated file, do not modify
const char* audioModule = "import \"io\" for FileSystem\n"
"// Represents the data of an audio file\n"
"// which can be loaded and unloaded\n"
"// It is otherwise opaque Wren-side\n"
"foreign class AudioData {\n"
"  construct init(buffer) {}\n"
"  static fromFile(path) {\n"
"    var data = AudioData.init(FileSystem.loadSync(path))\n"
"    System.print(\"Audio loaded: \" + path)\n"
"    return data\n"
"  }\n"
"  foreign unload()\n"
"}\n"
"\n"
"// Encapsulates the data of the currently playing channel\n"
"foreign class AudioChannel {\n"
"  construct new(id, audio) {}\n"
"  foreign isFinished\n"
"  foreign id\n"
"  foreign enabled=(id)\n"
"  foreign loop=(do)\n"
"  foreign pan=(pan)\n"
"  foreign volume=(volume)\n"
"}\n"
"\n"
"foreign class AudioEngineImpl {\n"
"  construct init() {\n"
"    __files = {}\n"
"    __channels = {}\n"
"    __newChannelId = 0\n"
"  }\n"
"  // TODO: Allow device enumeration and selection\n"
"\n"
"  // Loading and unloading\n"
"  // We only support loading WAV and OGG\n"
"  load(name, path) {\n"
"    if (!__files.containsKey(name)) {\n"
"      __files[name] = AudioData.fromFile(path)\n"
"    }\n"
"\n"
"    return __files[name]\n"
"  }\n"
"  unload(name) {\n"
"    if (__files.containsKey(name)) {\n"
"      __files[name] = null\n"
"    }\n"
"  }\n"
"\n"
"  unloadAll() {\n"
"    __files = {}\n"
"  }\n"
"\n"
"  // audio mix operations\n"
"  play(name) { play(name, 1, false, 0) }\n"
"  play(name, volume) { play(name, volume, false, 0) }\n"
"  play(name, volume, loop) { play(name, volume, loop, 0) }\n"
"  play(name, volume, loop, pan) {\n"
"    if (__files.containsKey(name)) {\n"
"      __newChannelId = __newChannelId + 1\n"
"      var channel = AudioChannel.new(__newChannelId, __files[name])\n"
"      __channels[__newChannelId] = channel\n"
"      channel.loop = loop\n"
"      channel.volume = volume\n"
"      channel.pan = pan\n"
"    }\n"
"\n"
"    return __newChannelId\n"
"  }\n"
"\n"
"  stopChannel(channelId) {\n"
"    if (__channels.containsKey(channelId)) {\n"
"      __channels[channelId].enabled = false\n"
"    }\n"
"  }\n"
"\n"
"  setChannelVolume(channelId, volume) {\n"
"    if (__channels.containsKey(channelId)) {\n"
"      __channels[channelId].volume = volume\n"
"    }\n"
"  }\n"
"\n"
"  setChannelPan(channelId, pan) {\n"
"    if (__channels.containsKey(channelId)) {\n"
"      __channels[channelId].pan = pan\n"
"    }\n"
"  }\n"
"\n"
"\n"
"  setChannelLoop(channelId, loop) {\n"
"    if (__channels.containsKey(channelId)) {\n"
"      __channels[channelId].loop = loop\n"
"    }\n"
"  }\n"
"\n"
"  stopAllChannels() {\n"
"    __channels.values.each { |channel| channel.enabled = false }\n"
"  }\n"
"\n"
"  isPlaying(channelId) {\n"
"    if (__channels.containsKey(channelId)) {\n"
"      return !__channels[channelId].isFinished\n"
"    }\n"
"    return false\n"
"  }\n"
"\n"
"  update() {\n"
"    var playing = __channels.values.where {|channel|\n"
"      var stillPlaying = !channel.isFinished\n"
"      if (!stillPlaying) {\n"
"        __channels.remove(channel.id)\n"
"      }\n"
"      return stillPlaying\n"
"    }.toList\n"
"    f_update(playing)\n"
"  }\n"
"  foreign f_update(list)\n"
"}\n"
"\n"
"// We only intend to expose this\n"
"var AudioEngine = AudioEngineImpl.init()\n"
"\n"
"// We need the same engine under a different name so that we can\n"
"// call it from C with a unique import.\n"
"var AudioEngine_internal = AudioEngine\n"
"";
